{"responses_create_params": {"input": [{"role": "user", "content": "You are a meticulous Bash command generator.\n\nGoal: Convert the natural-language request into ONE correct Bash command.\n\nConstraints:\n- Output MUST be a single bash command (no prose, no extra lines).\n- Prefer POSIX/GNU userland tools available on typical Linux (bash, find, grep, sed, awk, xargs, sort, uniq, cut, tr, head, tail, wc, du, df, ls, cat, cp, mv, rm, mkdir, rmdir, tar, gzip, chmod, chown, stat, printf).\n- Assume GNU versions of common tools (e.g., GNU findutils/coreutils).\n- Do NOT use interactive commands (no editors, no prompts).\n- Do NOT use placeholders like <file> or <path> unless the request itself uses them; infer reasonable defaults:\n  - If the request says “current directory/folder”, use . and do not recurse unless asked.\n  - If it says “entire filesystem”, use /.\n- Avoid unnecessary output formatting unless asked (e.g., no echo labels).\n- If multiple steps are required, compose a single command using pipes and/or && (still one shell line).\n- Do not use backticks. Prefer $(...) if command substitution is necessary.\n- Be precise with quoting and escaping (especially for spaces, globbing, and regex metacharacters).\n- Do not perform destructive actions unless explicitly requested (rm, mv over existing, etc.).\n\nUser request:\ndisplay all the regular files in the current folder that are exactly 10KB. Write your final response as a single bash command wrapped exactly like this:\n\nAnswer: ```sh\n<command>\n```\n\nWrite your final response as a single bash command wrapped exactly like this:\n\nAnswer: ```sh\n<command>\n```"}]}, "expected_answer": "find . -type f -size 10k"}
{"responses_create_params": {"input": [{"role": "user", "content": "You are a meticulous Bash command generator.\n\nGoal: Convert the natural-language request into ONE correct Bash command.\n\nConstraints:\n- Output MUST be a single bash command (no prose, no extra lines).\n- Prefer POSIX/GNU userland tools available on typical Linux (bash, find, grep, sed, awk, xargs, sort, uniq, cut, tr, head, tail, wc, du, df, ls, cat, cp, mv, rm, mkdir, rmdir, tar, gzip, chmod, chown, stat, printf).\n- Assume GNU versions of common tools (e.g., GNU findutils/coreutils).\n- Do NOT use interactive commands (no editors, no prompts).\n- Do NOT use placeholders like <file> or <path> unless the request itself uses them; infer reasonable defaults:\n  - If the request says “current directory/folder”, use . and do not recurse unless asked.\n  - If it says “entire filesystem”, use /.\n- Avoid unnecessary output formatting unless asked (e.g., no echo labels).\n- If multiple steps are required, compose a single command using pipes and/or && (still one shell line).\n- Do not use backticks. Prefer $(...) if command substitution is necessary.\n- Be precise with quoting and escaping (especially for spaces, globbing, and regex metacharacters).\n- Do not perform destructive actions unless explicitly requested (rm, mv over existing, etc.).\n\nUser request:\nfind all files  that names are 'apt'. Write your final response as a single bash command wrapped exactly like this:\n\nAnswer: ```sh\n<command>\n```\n\nWrite your final response as a single bash command wrapped exactly like this:\n\nAnswer: ```sh\n<command>\n```"}]}, "expected_answer": "find  / -name \"apt\""}
{"responses_create_params": {"input": [{"role": "user", "content": "You are a meticulous Bash command generator.\n\nGoal: Convert the natural-language request into ONE correct Bash command.\n\nConstraints:\n- Output MUST be a single bash command (no prose, no extra lines).\n- Prefer POSIX/GNU userland tools available on typical Linux (bash, find, grep, sed, awk, xargs, sort, uniq, cut, tr, head, tail, wc, du, df, ls, cat, cp, mv, rm, mkdir, rmdir, tar, gzip, chmod, chown, stat, printf).\n- Assume GNU versions of common tools (e.g., GNU findutils/coreutils).\n- Do NOT use interactive commands (no editors, no prompts).\n- Do NOT use placeholders like <file> or <path> unless the request itself uses them; infer reasonable defaults:\n  - If the request says “current directory/folder”, use . and do not recurse unless asked.\n  - If it says “entire filesystem”, use /.\n- Avoid unnecessary output formatting unless asked (e.g., no echo labels).\n- If multiple steps are required, compose a single command using pipes and/or && (still one shell line).\n- Do not use backticks. Prefer $(...) if command substitution is necessary.\n- Be precise with quoting and escaping (especially for spaces, globbing, and regex metacharacters).\n- Do not perform destructive actions unless explicitly requested (rm, mv over existing, etc.).\n\nUser request:\nReplaces any occurences of '*favicon.ico*' in any subfolder with file '/root/favicon.ico'. Write your final response as a single bash command wrapped exactly like this:\n\nAnswer: ```sh\n<command>\n```\n\nWrite your final response as a single bash command wrapped exactly like this:\n\nAnswer: ```sh\n<command>\n```"}]}, "expected_answer": "find . | grep favicon\\.ico | xargs -n 1 cp -f /root/favicon.ico"}
{"responses_create_params": {"input": [{"role": "user", "content": "You are a meticulous Bash command generator.\n\nGoal: Convert the natural-language request into ONE correct Bash command.\n\nConstraints:\n- Output MUST be a single bash command (no prose, no extra lines).\n- Prefer POSIX/GNU userland tools available on typical Linux (bash, find, grep, sed, awk, xargs, sort, uniq, cut, tr, head, tail, wc, du, df, ls, cat, cp, mv, rm, mkdir, rmdir, tar, gzip, chmod, chown, stat, printf).\n- Assume GNU versions of common tools (e.g., GNU findutils/coreutils).\n- Do NOT use interactive commands (no editors, no prompts).\n- Do NOT use placeholders like <file> or <path> unless the request itself uses them; infer reasonable defaults:\n  - If the request says “current directory/folder”, use . and do not recurse unless asked.\n  - If it says “entire filesystem”, use /.\n- Avoid unnecessary output formatting unless asked (e.g., no echo labels).\n- If multiple steps are required, compose a single command using pipes and/or && (still one shell line).\n- Do not use backticks. Prefer $(...) if command substitution is necessary.\n- Be precise with quoting and escaping (especially for spaces, globbing, and regex metacharacters).\n- Do not perform destructive actions unless explicitly requested (rm, mv over existing, etc.).\n\nUser request:\nPrint the grand total disk usage of all files listed in \"files.txt\". Write your final response as a single bash command wrapped exactly like this:\n\nAnswer: ```sh\n<command>\n```\n\nWrite your final response as a single bash command wrapped exactly like this:\n\nAnswer: ```sh\n<command>\n```"}]}, "expected_answer": "cat files.txt | xargs du -c | tail -1"}
{"responses_create_params": {"input": [{"role": "user", "content": "You are a meticulous Bash command generator.\n\nGoal: Convert the natural-language request into ONE correct Bash command.\n\nConstraints:\n- Output MUST be a single bash command (no prose, no extra lines).\n- Prefer POSIX/GNU userland tools available on typical Linux (bash, find, grep, sed, awk, xargs, sort, uniq, cut, tr, head, tail, wc, du, df, ls, cat, cp, mv, rm, mkdir, rmdir, tar, gzip, chmod, chown, stat, printf).\n- Assume GNU versions of common tools (e.g., GNU findutils/coreutils).\n- Do NOT use interactive commands (no editors, no prompts).\n- Do NOT use placeholders like <file> or <path> unless the request itself uses them; infer reasonable defaults:\n  - If the request says “current directory/folder”, use . and do not recurse unless asked.\n  - If it says “entire filesystem”, use /.\n- Avoid unnecessary output formatting unless asked (e.g., no echo labels).\n- If multiple steps are required, compose a single command using pipes and/or && (still one shell line).\n- Do not use backticks. Prefer $(...) if command substitution is necessary.\n- Be precise with quoting and escaping (especially for spaces, globbing, and regex metacharacters).\n- Do not perform destructive actions unless explicitly requested (rm, mv over existing, etc.).\n\nUser request:\nSplit \"t.txt\" into files with at most 30000000 lines each and use a prefix \"t\" and numeric suffixes of length 2. Write your final response as a single bash command wrapped exactly like this:\n\nAnswer: ```sh\n<command>\n```\n\nWrite your final response as a single bash command wrapped exactly like this:\n\nAnswer: ```sh\n<command>\n```"}]}, "expected_answer": "split --lines=30000000 --numeric-suffixes --suffix-length=2 t.txt t"}
