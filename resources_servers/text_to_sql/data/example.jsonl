{"responses_create_params": {"input": [{"role": "system", "content": "You are a SQL assistant who expertly maps natural language commands and problems into clean, efficient, and well-structured SQL queries. You always carefully examine the database context to include only the relevant tables and fields. You return only SQL code (no explanations outside of SQL code block; only proper comments are permitted). Wrap your SQL query inside a ```sql``` code block."}, {"role": "user", "content": "<DIALECT>mysql</DIALECT>\n\n<DATABASE_CONTEXT>\nCREATE TABLE weather_station (\n  station_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  station_name VARCHAR(100) NOT NULL,\n  latitude DECIMAL(9,6) NOT NULL,\n  longitude DECIMAL(9,6) NOT NULL,\n  installed_date DATE NOT NULL,\n  created_at DATETIME NOT NULL,\n  updated_at DATETIME NOT NULL,\n  is_active TINYINT(1) NOT NULL DEFAULT 1,\n  description TEXT\n) ENGINE=InnoDB;\n\nCREATE TABLE sensor (\n  sensor_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  station_id INT UNSIGNED NOT NULL,\n  sensor_type VARCHAR(50) NOT NULL,\n  calibration_date DATE NOT NULL,\n  serial_number VARCHAR(50),\n  firmware_version VARCHAR(20),\n  is_active TINYINT(1) NOT NULL DEFAULT 1,\n  created_at DATETIME NOT NULL,\n  updated_at DATETIME NOT NULL,\n  description TEXT,\n  FOREIGN KEY (station_id) REFERENCES weather_station(station_id)\n) ENGINE=InnoDB;\n\nCREATE TABLE sensor_log (\n  log_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  sensor_id INT UNSIGNED NOT NULL,\n  drift_date DATE NOT NULL,\n  temperature_deviation DECIMAL(5,2) NOT NULL,\n  reporting_email VARCHAR(150) NOT NULL,\n  log_url VARCHAR(255) NOT NULL,\n  readings TEXT NOT NULL,\n  created_at DATETIME NOT NULL,\n  updated_at DATETIME NOT NULL,\n  is_processed TINYINT(1) NOT NULL DEFAULT 0,\n  notes TEXT,\n  FOREIGN KEY (sensor_id) REFERENCES sensor(sensor_id)\n) ENGINE=InnoDB;\n\nINSERT INTO weather_station (station_name, latitude, longitude, installed_date, created_at, updated_at, is_active, description) VALUES\n('North Ridge', 45.123456, -122.654321, '2023-03-15', '2023-04-01 08:00:00', '2023-04-01 08:00:00', 1, 'High elevation site'),\n('East Valley', 44.987654, -122.112233, '2022-11-20', '2022-12-01 09:15:00', '2022-12-01 09:15:00', 1, NULL);\n\nINSERT INTO sensor (station_id, sensor_type, calibration_date, serial_number, firmware_version, is_active, created_at, updated_at, description) VALUES\n(1, 'Thermometer', '2025-01-01', 'SN-001', 'v1.2.0', 1, '2025-01-02 08:00:00', '2025-01-02 08:00:00', NULL),\n(2, 'Thermometer', '2024-12-10', 'SN-003', 'v1.1.3', 1, '2024-12-12 09:00:00', '2024-12-12 09:00:00', NULL);\n\nINSERT INTO sensor_log (sensor_id, drift_date, temperature_deviation, reporting_email, log_url, readings, created_at, updated_at, is_processed, notes) VALUES\n(1, '2025-07-01', 0.45, 'tech.north@example.com', 'http://logs.example.com/north/2025-07-01', '[21.2,21.5,21.7]', '2025-07-02 08:10:00', '2025-07-02 08:10:00', 1, NULL),\n(1, '2025-07-15', 0.30, 'ops.north@example.com', 'http://logs.example.com/north/2025-07-15', '[21.0,21.1]', '2025-07-16 08:12:00', '2025-07-16 08:12:00', 0, NULL),\n(2, '2025-07-03', -0.20, 'maintenance@eastvalley.org', 'http://logs.example.com/east/2025-07-03', '[19.8,20.0,20.2,20.3]', '2025-07-04 09:00:00', '2025-07-04 09:00:00', 1, NULL);\n</DATABASE_CONTEXT>\n\n<QUESTION>\nPlease retrieve for each weather station the latest sensor-drift date, the average temperature deviation, and the domain extracted from the reporting email within the sensor log URL, omitting any records whose embedded readings array contains fewer than three entries, and return the list ordered by descending average deviation.</QUESTION>"}]}, "sql": "WITH filtered_logs AS (\n  SELECT\n    sl.log_id,\n    s.station_id,\n    ws.station_name,\n    sl.drift_date,\n    sl.temperature_deviation,\n    SUBSTRING_INDEX(sl.reporting_email, '@', -1) AS email_domain\n  FROM sensor_log sl\n  JOIN sensor s ON sl.sensor_id = s.sensor_id\n  JOIN weather_station ws ON s.station_id = ws.station_id\n  WHERE (LENGTH(sl.readings) - LENGTH(REPLACE(sl.readings, ',', ''))) >= 2\n),\nagg AS (\n  SELECT\n    station_id,\n    station_name,\n    MAX(drift_date) AS latest_drift_date,\n    AVG(temperature_deviation) AS avg_temp_deviation\n  FROM filtered_logs\n  GROUP BY station_id, station_name\n),\nlatest_domain AS (\n  SELECT station_id, email_domain\n  FROM (\n    SELECT\n      fl.station_id,\n      fl.email_domain,\n      ROW_NUMBER() OVER (PARTITION BY fl.station_id ORDER BY fl.drift_date DESC) AS rn\n    FROM filtered_logs fl\n  ) t\n  WHERE rn = 1\n)\nSELECT\n  a.station_id,\n  a.station_name,\n  a.latest_drift_date,\n  ROUND(a.avg_temp_deviation, 2) AS avg_temp_deviation,\n  d.email_domain\nFROM agg a\nJOIN latest_domain d ON a.station_id = d.station_id\nORDER BY a.avg_temp_deviation DESC;", "sql_dialect": "mysql", "sql_prompt": "Please retrieve for each weather station the latest sensor-drift date, the average temperature deviation, and the domain extracted from the reporting email within the sensor log URL, omitting any records whose embedded readings array contains fewer than three entries, and return the list ordered by descending average deviation.", "sql_context": "CREATE TABLE weather_station (\n  station_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  station_name VARCHAR(100) NOT NULL,\n  latitude DECIMAL(9,6) NOT NULL,\n  longitude DECIMAL(9,6) NOT NULL,\n  installed_date DATE NOT NULL,\n  created_at DATETIME NOT NULL,\n  updated_at DATETIME NOT NULL,\n  is_active TINYINT(1) NOT NULL DEFAULT 1,\n  description TEXT\n) ENGINE=InnoDB;\n\nCREATE TABLE sensor (\n  sensor_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  station_id INT UNSIGNED NOT NULL,\n  sensor_type VARCHAR(50) NOT NULL,\n  calibration_date DATE NOT NULL,\n  serial_number VARCHAR(50),\n  firmware_version VARCHAR(20),\n  is_active TINYINT(1) NOT NULL DEFAULT 1,\n  created_at DATETIME NOT NULL,\n  updated_at DATETIME NOT NULL,\n  description TEXT,\n  FOREIGN KEY (station_id) REFERENCES weather_station(station_id)\n) ENGINE=InnoDB;\n\nCREATE TABLE sensor_log (\n  log_id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  sensor_id INT UNSIGNED NOT NULL,\n  drift_date DATE NOT NULL,\n  temperature_deviation DECIMAL(5,2) NOT NULL,\n  reporting_email VARCHAR(150) NOT NULL,\n  log_url VARCHAR(255) NOT NULL,\n  readings TEXT NOT NULL,\n  created_at DATETIME NOT NULL,\n  updated_at DATETIME NOT NULL,\n  is_processed TINYINT(1) NOT NULL DEFAULT 0,\n  notes TEXT,\n  FOREIGN KEY (sensor_id) REFERENCES sensor(sensor_id)\n) ENGINE=InnoDB;\n\nINSERT INTO weather_station (station_name, latitude, longitude, installed_date, created_at, updated_at, is_active, description) VALUES\n('North Ridge', 45.123456, -122.654321, '2023-03-15', '2023-04-01 08:00:00', '2023-04-01 08:00:00', 1, 'High elevation site'),\n('East Valley', 44.987654, -122.112233, '2022-11-20', '2022-12-01 09:15:00', '2022-12-01 09:15:00', 1, NULL);\n\nINSERT INTO sensor (station_id, sensor_type, calibration_date, serial_number, firmware_version, is_active, created_at, updated_at, description) VALUES\n(1, 'Thermometer', '2025-01-01', 'SN-001', 'v1.2.0', 1, '2025-01-02 08:00:00', '2025-01-02 08:00:00', NULL),\n(2, 'Thermometer', '2024-12-10', 'SN-003', 'v1.1.3', 1, '2024-12-12 09:00:00', '2024-12-12 09:00:00', NULL);\n\nINSERT INTO sensor_log (sensor_id, drift_date, temperature_deviation, reporting_email, log_url, readings, created_at, updated_at, is_processed, notes) VALUES\n(1, '2025-07-01', 0.45, 'tech.north@example.com', 'http://logs.example.com/north/2025-07-01', '[21.2,21.5,21.7]', '2025-07-02 08:10:00', '2025-07-02 08:10:00', 1, NULL),\n(1, '2025-07-15', 0.30, 'ops.north@example.com', 'http://logs.example.com/north/2025-07-15', '[21.0,21.1]', '2025-07-16 08:12:00', '2025-07-16 08:12:00', 0, NULL),\n(2, '2025-07-03', -0.20, 'maintenance@eastvalley.org', 'http://logs.example.com/east/2025-07-03', '[19.8,20.0,20.2,20.3]', '2025-07-04 09:00:00', '2025-07-04 09:00:00', 1, NULL);", "uuid": "weather-station-001"}
{"responses_create_params": {"input": [{"role": "system", "content": "You are a SQL assistant who expertly maps natural language commands and problems into clean, efficient, and well-structured SQL queries. You always carefully examine the database context to include only the relevant tables and fields. You return only SQL code (no explanations outside of SQL code block; only proper comments are permitted). Wrap your SQL query inside a ```sql``` code block."}, {"role": "user", "content": "<DIALECT>postgresql</DIALECT>\n\n<DATABASE_CONTEXT>\nCREATE TABLE customers (\n  customer_id SERIAL PRIMARY KEY,\n  name VARCHAR(100) NOT NULL,\n  email VARCHAR(150) UNIQUE NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE orders (\n  order_id SERIAL PRIMARY KEY,\n  customer_id INT REFERENCES customers(customer_id),\n  order_date DATE NOT NULL,\n  total_amount DECIMAL(10,2) NOT NULL,\n  status VARCHAR(20) DEFAULT 'pending'\n);\n\nINSERT INTO customers (name, email) VALUES\n('Alice Smith', 'alice@example.com'),\n('Bob Jones', 'bob@example.com'),\n('Carol White', 'carol@example.com');\n\nINSERT INTO orders (customer_id, order_date, total_amount, status) VALUES\n(1, '2025-01-15', 150.00, 'completed'),\n(1, '2025-02-20', 200.00, 'completed'),\n(1, '2025-03-10', 75.00, 'completed'),\n(1, '2025-04-05', 125.00, 'completed'),\n(2, '2025-01-20', 300.00, 'completed'),\n(2, '2025-02-25', 450.00, 'pending');\n</DATABASE_CONTEXT>\n\n<QUESTION>\nFind all customers who have placed more than 3 orders with a total spending exceeding $500, showing their name, email, order count, and total spent, sorted by total spent descending.</QUESTION>"}]}, "sql": "SELECT\n  c.name,\n  c.email,\n  COUNT(o.order_id) AS order_count,\n  SUM(o.total_amount) AS total_spent\nFROM customers c\nJOIN orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id, c.name, c.email\nHAVING COUNT(o.order_id) > 3 AND SUM(o.total_amount) > 500\nORDER BY total_spent DESC;", "sql_dialect": "postgresql", "sql_prompt": "Find all customers who have placed more than 3 orders with a total spending exceeding $500, showing their name, email, order count, and total spent, sorted by total spent descending.", "sql_context": "CREATE TABLE customers (\n  customer_id SERIAL PRIMARY KEY,\n  name VARCHAR(100) NOT NULL,\n  email VARCHAR(150) UNIQUE NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nCREATE TABLE orders (\n  order_id SERIAL PRIMARY KEY,\n  customer_id INT REFERENCES customers(customer_id),\n  order_date DATE NOT NULL,\n  total_amount DECIMAL(10,2) NOT NULL,\n  status VARCHAR(20) DEFAULT 'pending'\n);\n\nINSERT INTO customers (name, email) VALUES\n('Alice Smith', 'alice@example.com'),\n('Bob Jones', 'bob@example.com'),\n('Carol White', 'carol@example.com');\n\nINSERT INTO orders (customer_id, order_date, total_amount, status) VALUES\n(1, '2025-01-15', 150.00, 'completed'),\n(1, '2025-02-20', 200.00, 'completed'),\n(1, '2025-03-10', 75.00, 'completed'),\n(1, '2025-04-05', 125.00, 'completed'),\n(2, '2025-01-20', 300.00, 'completed'),\n(2, '2025-02-25', 450.00, 'pending');", "uuid": "ecommerce-001"}
{"responses_create_params": {"input": [{"role": "system", "content": "You are a SQL assistant who expertly maps natural language commands and problems into clean, efficient, and well-structured SQL queries. You always carefully examine the database context to include only the relevant tables and fields. You return only SQL code (no explanations outside of SQL code block; only proper comments are permitted). Wrap your SQL query inside a ```sql``` code block."}, {"role": "user", "content": "<DIALECT>sqlite</DIALECT>\n\n<DATABASE_CONTEXT>\nCREATE TABLE employees (\n  employee_id INTEGER PRIMARY KEY AUTOINCREMENT,\n  first_name TEXT NOT NULL,\n  last_name TEXT NOT NULL,\n  department TEXT NOT NULL,\n  hire_date TEXT NOT NULL,\n  salary REAL NOT NULL,\n  manager_id INTEGER REFERENCES employees(employee_id)\n);\n\nCREATE TABLE projects (\n  project_id INTEGER PRIMARY KEY AUTOINCREMENT,\n  project_name TEXT NOT NULL,\n  start_date TEXT NOT NULL,\n  end_date TEXT,\n  budget REAL NOT NULL\n);\n\nCREATE TABLE project_assignments (\n  assignment_id INTEGER PRIMARY KEY AUTOINCREMENT,\n  employee_id INTEGER REFERENCES employees(employee_id),\n  project_id INTEGER REFERENCES projects(project_id),\n  role TEXT NOT NULL,\n  hours_allocated INTEGER NOT NULL\n);\n\nINSERT INTO employees (first_name, last_name, department, hire_date, salary) VALUES\n('John', 'Doe', 'Engineering', '2020-01-15', 85000),\n('Jane', 'Smith', 'Engineering', '2019-06-20', 92000),\n('Bob', 'Johnson', 'Sales', '2021-03-10', 75000);\n\nINSERT INTO projects (project_name, start_date, end_date, budget) VALUES\n('Project Alpha', '2025-01-01', '2025-06-30', 500000),\n('Project Beta', '2025-02-15', NULL, 750000),\n('Project Gamma', '2025-03-01', '2025-12-31', 300000);\n\nINSERT INTO project_assignments (employee_id, project_id, role, hours_allocated) VALUES\n(1, 1, 'Developer', 160),\n(1, 2, 'Lead Developer', 200),\n(2, 1, 'Architect', 120),\n(2, 2, 'Developer', 180),\n(2, 3, 'Consultant', 40);\n</DATABASE_CONTEXT>\n\n<QUESTION>\nList all employees who are assigned to more than one project, showing their full name, department, and the number of projects they're working on.</QUESTION>"}]}, "sql": "SELECT\n  e.first_name || ' ' || e.last_name AS full_name,\n  e.department,\n  COUNT(DISTINCT pa.project_id) AS project_count\nFROM employees e\nJOIN project_assignments pa ON e.employee_id = pa.employee_id\nGROUP BY e.employee_id, e.first_name, e.last_name, e.department\nHAVING COUNT(DISTINCT pa.project_id) > 1;", "sql_dialect": "sqlite", "sql_prompt": "List all employees who are assigned to more than one project, showing their full name, department, and the number of projects they're working on.", "sql_context": "CREATE TABLE employees (\n  employee_id INTEGER PRIMARY KEY AUTOINCREMENT,\n  first_name TEXT NOT NULL,\n  last_name TEXT NOT NULL,\n  department TEXT NOT NULL,\n  hire_date TEXT NOT NULL,\n  salary REAL NOT NULL,\n  manager_id INTEGER REFERENCES employees(employee_id)\n);\n\nCREATE TABLE projects (\n  project_id INTEGER PRIMARY KEY AUTOINCREMENT,\n  project_name TEXT NOT NULL,\n  start_date TEXT NOT NULL,\n  end_date TEXT,\n  budget REAL NOT NULL\n);\n\nCREATE TABLE project_assignments (\n  assignment_id INTEGER PRIMARY KEY AUTOINCREMENT,\n  employee_id INTEGER REFERENCES employees(employee_id),\n  project_id INTEGER REFERENCES projects(project_id),\n  role TEXT NOT NULL,\n  hours_allocated INTEGER NOT NULL\n);\n\nINSERT INTO employees (first_name, last_name, department, hire_date, salary) VALUES\n('John', 'Doe', 'Engineering', '2020-01-15', 85000),\n('Jane', 'Smith', 'Engineering', '2019-06-20', 92000),\n('Bob', 'Johnson', 'Sales', '2021-03-10', 75000);\n\nINSERT INTO projects (project_name, start_date, end_date, budget) VALUES\n('Project Alpha', '2025-01-01', '2025-06-30', 500000),\n('Project Beta', '2025-02-15', NULL, 750000),\n('Project Gamma', '2025-03-01', '2025-12-31', 300000);\n\nINSERT INTO project_assignments (employee_id, project_id, role, hours_allocated) VALUES\n(1, 1, 'Developer', 160),\n(1, 2, 'Lead Developer', 200),\n(2, 1, 'Architect', 120),\n(2, 2, 'Developer', 180),\n(2, 3, 'Consultant', 40);", "uuid": "hr-projects-001"}
{"responses_create_params": {"input": [{"role": "system", "content": "You are a SQL assistant who expertly maps natural language commands and problems into clean, efficient, and well-structured SQL queries. You always carefully examine the database context to include only the relevant tables and fields. You return only SQL code (no explanations outside of SQL code block; only proper comments are permitted). Wrap your SQL query inside a ```sql``` code block."}, {"role": "user", "content": "<DIALECT>mysql</DIALECT>\n\n<DATABASE_CONTEXT>\nCREATE TABLE products (\n  product_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category VARCHAR(50) NOT NULL,\n  price DECIMAL(10,2) NOT NULL,\n  stock_quantity INT NOT NULL DEFAULT 0,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n) ENGINE=InnoDB;\n\nCREATE TABLE sales (\n  sale_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  product_id INT UNSIGNED NOT NULL,\n  sale_date DATE NOT NULL,\n  quantity_sold INT NOT NULL,\n  revenue DECIMAL(10,2) NOT NULL,\n  FOREIGN KEY (product_id) REFERENCES products(product_id)\n) ENGINE=InnoDB;\n\nINSERT INTO products (product_name, category, price, stock_quantity) VALUES\n('Laptop Pro', 'Electronics', 1299.99, 50),\n('Wireless Mouse', 'Electronics', 29.99, 200),\n('Office Chair', 'Furniture', 249.99, 75),\n('Standing Desk', 'Furniture', 599.99, 30),\n('USB Hub', 'Electronics', 39.99, 150);\n\nINSERT INTO sales (product_id, sale_date, quantity_sold, revenue) VALUES\n(1, '2025-01-15', 10, 12999.90),\n(2, '2025-01-15', 50, 1499.50),\n(1, '2025-02-10', 8, 10399.92),\n(3, '2025-02-15', 20, 4999.80),\n(4, '2025-02-20', 5, 2999.95),\n(2, '2025-03-01', 100, 2999.00),\n(5, '2025-03-05', 75, 2999.25);\n</DATABASE_CONTEXT>\n\n<QUESTION>\nFor each product category, find the top-selling product (by total quantity sold) and show the category, product name, and total units sold.</QUESTION>"}]}, "sql": "WITH category_sales AS (\n  SELECT\n    p.category,\n    p.product_id,\n    p.product_name,\n    SUM(s.quantity_sold) AS total_sold,\n    ROW_NUMBER() OVER (PARTITION BY p.category ORDER BY SUM(s.quantity_sold) DESC) AS rn\n  FROM products p\n  JOIN sales s ON p.product_id = s.product_id\n  GROUP BY p.category, p.product_id, p.product_name\n)\nSELECT category, product_name, total_sold\nFROM category_sales\nWHERE rn = 1;", "sql_dialect": "mysql", "sql_prompt": "For each product category, find the top-selling product (by total quantity sold) and show the category, product name, and total units sold.", "sql_context": "CREATE TABLE products (\n  product_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  product_name VARCHAR(200) NOT NULL,\n  category VARCHAR(50) NOT NULL,\n  price DECIMAL(10,2) NOT NULL,\n  stock_quantity INT NOT NULL DEFAULT 0,\n  created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n) ENGINE=InnoDB;\n\nCREATE TABLE sales (\n  sale_id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,\n  product_id INT UNSIGNED NOT NULL,\n  sale_date DATE NOT NULL,\n  quantity_sold INT NOT NULL,\n  revenue DECIMAL(10,2) NOT NULL,\n  FOREIGN KEY (product_id) REFERENCES products(product_id)\n) ENGINE=InnoDB;\n\nINSERT INTO products (product_name, category, price, stock_quantity) VALUES\n('Laptop Pro', 'Electronics', 1299.99, 50),\n('Wireless Mouse', 'Electronics', 29.99, 200),\n('Office Chair', 'Furniture', 249.99, 75),\n('Standing Desk', 'Furniture', 599.99, 30),\n('USB Hub', 'Electronics', 39.99, 150);\n\nINSERT INTO sales (product_id, sale_date, quantity_sold, revenue) VALUES\n(1, '2025-01-15', 10, 12999.90),\n(2, '2025-01-15', 50, 1499.50),\n(1, '2025-02-10', 8, 10399.92),\n(3, '2025-02-15', 20, 4999.80),\n(4, '2025-02-20', 5, 2999.95),\n(2, '2025-03-01', 100, 2999.00),\n(5, '2025-03-05', 75, 2999.25);", "uuid": "sales-analytics-001"}
{"responses_create_params": {"input": [{"role": "system", "content": "You are a SQL assistant who expertly maps natural language commands and problems into clean, efficient, and well-structured SQL queries. You always carefully examine the database context to include only the relevant tables and fields. You return only SQL code (no explanations outside of SQL code block; only proper comments are permitted). Wrap your SQL query inside a ```sql``` code block."}, {"role": "user", "content": "<DIALECT>postgresql</DIALECT>\n\n<DATABASE_CONTEXT>\nCREATE TABLE users (\n  user_id SERIAL PRIMARY KEY,\n  username VARCHAR(50) UNIQUE NOT NULL,\n  email VARCHAR(150) NOT NULL,\n  registration_date DATE NOT NULL,\n  is_premium BOOLEAN DEFAULT FALSE\n);\n\nCREATE TABLE posts (\n  post_id SERIAL PRIMARY KEY,\n  user_id INT REFERENCES users(user_id),\n  title VARCHAR(200) NOT NULL,\n  content TEXT,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  view_count INT DEFAULT 0\n);\n\nCREATE TABLE comments (\n  comment_id SERIAL PRIMARY KEY,\n  post_id INT REFERENCES posts(post_id),\n  user_id INT REFERENCES users(user_id),\n  comment_text TEXT NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nINSERT INTO users (username, email, registration_date, is_premium) VALUES\n('alice_dev', 'alice@example.com', '2024-01-15', TRUE),\n('bob_writer', 'bob@example.com', '2024-02-20', FALSE),\n('carol_blogger', 'carol@example.com', '2024-03-10', TRUE);\n\nINSERT INTO posts (user_id, title, content, view_count) VALUES\n(1, 'Getting Started with PostgreSQL', 'A beginner guide...', 1500),\n(1, 'Advanced SQL Techniques', 'Deep dive into...', 2300),\n(1, 'Database Optimization', 'Tips for performance...', 1800),\n(1, 'SQL Best Practices', 'Industry standards...', 900),\n(1, 'Query Tuning Guide', 'How to optimize...', 1200),\n(2, 'Writing Tips', 'How to write better...', 500),\n(3, 'My First Blog Post', 'Hello world!', 100);\n\nINSERT INTO comments (post_id, user_id, comment_text) VALUES\n(1, 2, 'Great introduction!'),\n(1, 3, 'Very helpful, thanks!'),\n(2, 2, 'Learned a lot from this'),\n(2, 3, 'Can you elaborate on CTEs?'),\n(3, 2, 'Nice tips!'),\n(4, 3, 'Following these now'),\n(5, 2, 'Bookmarked for later');\n</DATABASE_CONTEXT>\n\n<QUESTION>\nFind the average number of comments per post for each user, but only include users who have created at least 5 posts. Show username, total posts, total comments received, and average comments per post.</QUESTION>"}]}, "sql": "SELECT\n  u.username,\n  COUNT(DISTINCT p.post_id) AS total_posts,\n  COUNT(c.comment_id) AS total_comments,\n  ROUND(COUNT(c.comment_id)::NUMERIC / COUNT(DISTINCT p.post_id), 2) AS avg_comments_per_post\nFROM users u\nJOIN posts p ON u.user_id = p.user_id\nLEFT JOIN comments c ON p.post_id = c.post_id\nGROUP BY u.user_id, u.username\nHAVING COUNT(DISTINCT p.post_id) >= 5\nORDER BY avg_comments_per_post DESC;", "sql_dialect": "postgresql", "sql_prompt": "Find the average number of comments per post for each user, but only include users who have created at least 5 posts. Show username, total posts, total comments received, and average comments per post.", "sql_context": "CREATE TABLE users (\n  user_id SERIAL PRIMARY KEY,\n  username VARCHAR(50) UNIQUE NOT NULL,\n  email VARCHAR(150) NOT NULL,\n  registration_date DATE NOT NULL,\n  is_premium BOOLEAN DEFAULT FALSE\n);\n\nCREATE TABLE posts (\n  post_id SERIAL PRIMARY KEY,\n  user_id INT REFERENCES users(user_id),\n  title VARCHAR(200) NOT NULL,\n  content TEXT,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  view_count INT DEFAULT 0\n);\n\nCREATE TABLE comments (\n  comment_id SERIAL PRIMARY KEY,\n  post_id INT REFERENCES posts(post_id),\n  user_id INT REFERENCES users(user_id),\n  comment_text TEXT NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\nINSERT INTO users (username, email, registration_date, is_premium) VALUES\n('alice_dev', 'alice@example.com', '2024-01-15', TRUE),\n('bob_writer', 'bob@example.com', '2024-02-20', FALSE),\n('carol_blogger', 'carol@example.com', '2024-03-10', TRUE);\n\nINSERT INTO posts (user_id, title, content, view_count) VALUES\n(1, 'Getting Started with PostgreSQL', 'A beginner guide...', 1500),\n(1, 'Advanced SQL Techniques', 'Deep dive into...', 2300),\n(1, 'Database Optimization', 'Tips for performance...', 1800),\n(1, 'SQL Best Practices', 'Industry standards...', 900),\n(1, 'Query Tuning Guide', 'How to optimize...', 1200),\n(2, 'Writing Tips', 'How to write better...', 500),\n(3, 'My First Blog Post', 'Hello world!', 100);\n\nINSERT INTO comments (post_id, user_id, comment_text) VALUES\n(1, 2, 'Great introduction!'),\n(1, 3, 'Very helpful, thanks!'),\n(2, 2, 'Learned a lot from this'),\n(2, 3, 'Can you elaborate on CTEs?'),\n(3, 2, 'Nice tips!'),\n(4, 3, 'Following these now'),\n(5, 2, 'Bookmarked for later');", "uuid": "social-media-001"}
